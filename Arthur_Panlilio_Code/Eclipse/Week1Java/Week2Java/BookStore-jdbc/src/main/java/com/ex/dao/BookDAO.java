package com.ex.dao;


import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import com.ex.pojos.Book;
import com.ex.util.ConnectionFactory;

import oracle.jdbc.internal.OracleTypes;

public class BookDAO implements Dao<Book, Integer>{
	
	@Override
	public List<Book> findAll(){
		/*
		 *  Callable Statement
		 *  -Extends PreparedStatement
		 *  -Allows us to execute stored procedures
		 *  -Must register our IN and OUT parameter
		 *  values and types
		 *  -IN params will be set using setter methods
		 *  inherited from PreparedStatement
		 *  can return 1 or many ResultSet objects
		 *  
		 *  
		 * Result set
		 * is a table of data representing a DB resultset 
		 * Generated by executing a SQL stmt
		 * it maintains a cursor pointing to the current 
		 * row (however, it is initially positioned 
		 * Before the first row). The RS.next() method
		 * moves that cursor to each subsequent row until
		 * there are no more rows (returns false);
		 */
		List<Book> books = new ArrayList<>();
		try(Connection conn = ConnectionFactory.getInstance().getConnection()){
			String sql = "{call get_all_books(?)}";
			
			CallableStatement cs = conn.prepareCall(sql);
			cs.registerOutParameter(1, OracleTypes.CURSOR);
			cs.execute();
			
			ResultSet rs = (ResultSet) cs.getObject(1);	
			while(rs.next()) {
				Book temp = new Book();
				temp.setId(rs.getInt("book_id"));
				temp.setIsbn(rs.getString("isbn"));
				temp.setTitle(rs.getString("title"));
				temp.setPrice(rs.getDouble("price"));
				temp.setGenreId(rs.getInt("genre_id"));
				books.add(temp);
			}
			
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		return books;
	}

	@Override
	public Book findOne(Integer id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Book save(Book b) {
		System.out.println("A");
		try(Connection conn = ConnectionFactory.getInstance()
				.getConnection()){
			//connections automatically commit after tx is complete, set to false to do some sort of validation
			conn.setAutoCommit(false);					
			String sql = "INSERT INTO book (isbn, title, price, genre_id) VALUES (?,?,?,?)";
			//code to get back auto-generated PK (other columns can be auto generated too)
			String[] keys = {"book_id"};
			
			PreparedStatement ps = conn.prepareStatement(sql, keys);
			ps.setString(1, b.getIsbn());
			ps.setString(2, b.getTitle());
			ps.setDouble(3, b.getPrice());
			ps.setInt(4, b.getGenreId());
			
			//Updates return num rows added/updated/delted
			//Queries return result sets
			int numRowsAffect  = ps.executeUpdate();
			if(numRowsAffect > 0) {
				ResultSet pk = ps.getGeneratedKeys();
				while(pk.next()) {
					System.out.println(pk.toString());
					b.setId(pk.getInt(1));
				}
			}
			
			conn.commit();
		} catch (SQLException e) {
			
		}
		return b;
	}

	@Override
	public Book update(Book obj) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void delete(Book obj) {
		// TODO Auto-generated method stub
		
	}

}
