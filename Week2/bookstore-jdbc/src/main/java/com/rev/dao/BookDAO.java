package com.rev.dao;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import com.rev.pojos.Book;
import com.rev.util.ConnectionFactory;

public class BookDAO  implements Dao<Book,Integer>{

	//don't put main method in dao class. best practice
		public static void main(String[] args) {
			List<Book> books = findAll();
			
			for(Book b: books) {
				System.out.println(b);
			}
		}

		public static List<Book> findAll() {
			//gives this method the ability to make this any type of list. you don't need to worry of the type of 
			//list when you call this method.
			List<Book> books = new ArrayList<Book>();
			try (Connection conn = ConnectionFactory
					.getInstance().getConnection()){ //singleton so you don't use 'new'
				String query = "select * from book";
				//STATEMENT INTERFACE
				//Connection is really important interface. you can only instantiate things that implement connection
				Statement statement = conn.createStatement();
				
				//now get result set. (any executeUpdate is going to return number of rows affected)
				ResultSet rs = statement.executeQuery(query);
				
				//iterate through result set. each row
				while(rs.next()) {
					Book temp = new Book();
					temp.setId(rs.getInt(1));
					temp.setIsbn(rs.getString(2));
					temp.setTitle(rs.getString(3));
					temp.setPrice(rs.getInt(4));
					temp.setGenreId(rs.getInt(5));
													
					books.add(temp);
				}
				

			} catch(SQLException e) {
				e.printStackTrace();
			}
			return books;
		}

		@Override
		public List<Book> findAll() {
			/*
			 * callable statement 
			 * it extends PreparedStatement
			 * allows us to execute sotred procedures
			 * must register our IN and OUT parameter values and types
			 * IN params will be set using setter methods inherited from PreparedStatement
			 * can return 1 or many ResultSet objects
			 * 
			 * ResultSet
			 * -table of data representing a db resultset generated by executing a sql statement
			 * maintains a cursor pointint to the current row (however, 
			 * it is initially positioned before the first row).
			 * the RS.next() method moves that cursor to each subsequent 
			 * row until there are no more rows (returns false)
			 */
			try(Connection c = ConnectionFactory.getInstance().getConnection()){
				
			}
			return null;
		}

		@Override
		public Book findOne(Integer id) {
			// TODO Auto-generated method stub
			return null;
		}

		@Override
		public Book save(Book obj) {
			// TODO Auto-generated method stub
			return null;
		}

		@Override
		public Book update(Book obj) {
			// TODO Auto-generated method stub
			return null;
		}

		@Override
		public void delete(Book obj) {
			// TODO Auto-generated method stub
			
		}	
	

}
